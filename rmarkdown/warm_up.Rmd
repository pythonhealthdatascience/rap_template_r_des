---
title: "Warm up period"
author: "Amy Heather"
date: "`r Sys.Date()`"
output:
  github_document:
      toc: true
      html_preview: false
---

## Set up

Install the latest version of the local simulation package.

```{r}
devtools::load_all()
```

Import required packages.

```{r}
# nolint start: undesirable_function_linter.
library(simulation)
library(dplyr)
library(tidyr)

options(dplyr.summarise.inform = FALSE)
# nolint end
```

Start timer.

```{r}
start_time <- Sys.time()
```

Define path to outputs folder.

```{r}
output_dir <- file.path("..", "outputs")
```

## Attempt at incorporating a warm-up period into `model.py`

### Run the model

Run the model for `warm_up_period` + `data_collection_period`...

To illustrate our problem, have temporarily add another resource: doctor.

```{r}
run_number <- 1
param <- parameters()
set_seed <- TRUE
number_of_doctors <- 3

param$warm_up_period
param$data_collection_period
```

```{r}
# Check all inputs are valid
valid_inputs(run_number, param)

# Set random seed based on run number
if (set_seed) {
  set.seed(run_number)
}

# Define the patient trajectory
patient <- trajectory("appointment") %>%
  seize("nurse", 1L) %>%
  timeout(function() {
    rexp(n = 1L, rate = 1L / param[["mean_n_consult_time"]])
  }) %>%
  release("nurse", 1L) %>%
  seize("doctor", 1L) %>%
  timeout(function() {
    rexp(n = 1L, rate = 1L / param[["mean_n_consult_time"]])
  }) %>%
  release("doctor", 1L)

# Determine whether to get verbose activity logs
verbose <- any(c(param[["log_to_console"]], param[["log_to_file"]]))

# Create simmer environment, add nurse resource and patient generator, and
# run the simulation. Capture output, which will save a log if verbose=TRUE
sim_log <- capture.output(
  env <- simmer("simulation", verbose = verbose) %>% # nolint
    add_resource("nurse", param[["number_of_nurses"]]) %>%
    add_resource("doctor", number_of_doctors) %>%
    add_generator("patient", patient, function() {
      rexp(n = 1L, rate = 1L / param[["patient_inter"]])
    }) %>%
    simmer::run(param[["warm_up_period"]] +
                param[["data_collection_period"]]) %>%
    wrap()
)
```

### Trim the `arrivals` and `resources` dataframes produced

Label warm-up and data-collection patients in the `arrivals` dataframe.

```{r}
arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)

# Add column marking warm-up (wu) and data-collection (dc) patients
arrivals <- arrivals %>%
  group_by(name) %>%
  # filter(all(start_time >= param[["warm_up_period"]])) %>%
  mutate(period = if_else(
    any(start_time < param[["warm_up_period"]]), "wu", "dc"
  )) %>%
  ungroup()
arrivals
```

As `resources` does not contain only information on which patient they were associated with, we need to match the resource start time with the patient activity start times.

First, we must calculate the `resource_start_time` (as the `start_time` in `arrivals` may be earlier if the patient had to wait for the resource).

```{r}
# Add column recording the resource start time (excluding wait time for resource)
arrivals[["resource_start_time"]] <- (
  arrivals[["end_time"]] - arrivals[["activity_time"]]
)
arrivals
```

**Question:** Is `resource_start_time` just the same as start time? If patients had to wait for a resource, does activity_time include that?

**Answer:** No.

```{r}
# Instances where start_time is different from resource_start_time
arrivals[round(arrivals$start_time, 10) != round(arrivals$resource_start_time, 10),]
```

In the `resources` dataframe, we just has `time` (which is for an event - including start time or end time).

```{r}
resources <- get_mon_resources(env)
resources
```

```{r}
# Create arrivals dataframe with rows for each patient's resource start and end time
arrivals_times <- arrivals %>%
  select(name, resource, resource_start_time, end_time, replication, period) %>%
  pivot_longer(cols = c(resource_start_time, end_time),
               names_to = "time_type",
               values_to = "time_value")

arrivals_times
```

```{r}
# Sort both dataframes by time and round (otherwise everything doesn't match
# due to floating point differences)
decimal_places <- 10

arrivals_times <- arrivals_times %>%
  arrange(time_value) %>%
  mutate(time_value_r = round(time_value, decimal_places))

resources <- resources %>%
  mutate(time_r = round(time, decimal_places))

# Preview
arrivals_times
resources
```

```{r}
# Merge the dataframes
matched_data <- left_join(
  resources, arrivals_times,
  by = c("time_r" = "time_value_r",
         "resource" = "resource",
         "replication" = "replication")
)
matched_data
```

Unfortunately, some resources had no match, which is not allowable, as they must be associated with a patient, remaining the case even if we round by more decimal places (unshown).

```{r}
matched_data[is.na(matched_data[["name"]]),]
```

Looking manually...

#### nurse 60.36518

No match in `arrivals_times`

```{r}
arrivals_times %>%
  arrange(time_value) %>%
  filter(time_value > 58 & time_value < 62)
```

Does match in `arrivals` - interestingly, to `start_time` rather than `resource_start_time`.

```{r}
arrivals %>%
  arrange(start_time) %>%
  filter(start_time > 58 & start_time < 62)
```

This is because that entry in resources is about someone joining the queue, and not about a resource being used.

Can check this by seeing that `patient15` has matches for the resource_start_time and end_time...

```{r}
matched_data[matched_data[["name"]] == "patient15",]
```

Hence, the **solution** could be:

* To have `start_time` as an additional `time_type` ONLY IF they experienced a wait, or-
* To filter `resources` to only contain rows from patients capturing or releasing a resource and not joining the queue

BUT: note that my plans could have unintended calculations if I remove rows (either from approach in general, or from the latter item) that are required by the calculations.

## Understanding the times in arrivals

```{r}
arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)
arrivals %>%
  mutate(total_time = end_time - start_time) %>%
  filter(total_time > activity_time)
```

## Inspired by `treat-sim-simmer`

Calculate utilisation from `get_mon_arrivals()` (and do not use `get_mon_resources()`).

```{r}
# Filter to patients who arrived after the warm-up period
arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE) %>%
  group_by(name) %>%
  filter(all(start_time >= param[["warm_up_period"]])) %>%
  ungroup()

resource_counts <- tibble(
  resource = c("doctor", "nurse"),
  count = c(number_of_doctors, param[["number_of_nurses"]])
)

# Calculate utilisation
arrivals %>%
  mutate(waiting_time = end_time - start_time - activity_time) %>%
  group_by(resource) %>%
  summarise(in_use = sum(activity_time, na.rm=TRUE)) %>%
  merge(resource_counts, by = "resource", all=TRUE) %>%
  mutate(utilisation = in_use / (param[["data_collection_period"]] * count))
```

## Attempt using `reset()`

```{r}
run_number <- 1
param <- parameters(
  patient_inter = 5,
  mean_n_consult_time = 20,
  number_of_nurses = 1,
  warm_up_period = 80,
  data_collection_period = 80
)
set_seed <- TRUE
number_of_doctors <- 3

# Check all inputs are valid
valid_inputs(run_number, param)

# Set random seed based on run number
if (set_seed) {
  set.seed(run_number)
}

# Define the patient trajectory
patient <- trajectory("appointment") %>%
  seize("nurse", 1L) %>%
  timeout(function() {
    rexp(n = 1L, rate = 1L / param[["mean_n_consult_time"]])
  }) %>%
  release("nurse", 1L)

# Create simmer environment, add nurse resource and patient generator
env <- simmer("simulation", verbose = verbose) %>% # nolint
  add_resource("nurse", param[["number_of_nurses"]]) %>%
  add_generator("patient", patient, function() {
    rexp(n = 1L, rate = 1L / param[["patient_inter"]])
  })

# Run the warm-up period
env %>%
  simmer::run(param[["warm_up_period"]])

# Extract monitoring data *before* the reset
wu_arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)
wu_resources <- get_mon_resources(env)

# Reset the environment to clear statistics
env %>%
  simmer::reset()

# Run the data collection period
sim_log <- capture.output(
  env %>%
    simmer::run(param[["data_collection_period"]]) %>%
    wrap()
)

# Extract monitoring data *after* the reset
arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)
resources <- get_mon_resources(env)

# Display
wu_arrivals %>% arrange(start_time)
wu_resources
arrivals %>% arrange(start_time)
resources
```

It appears that in `wu_arrivals`, patients `end_time` = NA in some cases as not yet seen but in others as they start being seen but not finished before end of simulation.

**TODO:** Find a way to distinguish patients still waiting for a resource v.s. patients in ongoing session with resource (perhaps by matching with resource times).

When we reset, these are no longer monitored so not included in the new dataframes. However, I am concerned they simply no longer exist, as the patients in `arrivals` should all be waiting and not seen immediately, but `patient0` seems to be seen as soon as they arrive.

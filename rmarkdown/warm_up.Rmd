---
title: "Warm up period"
author: "Amy Heather"
date: "`r Sys.Date()`"
output:
  github_document:
      toc: true
      html_preview: false
---

## Set up

Install the latest version of the local simulation package.

```{r}
devtools::load_all()
```

Import required packages.

```{r}
# nolint start: undesirable_function_linter.
library(simulation)
library(dplyr)
library(tidyr)

options(dplyr.summarise.inform = FALSE)
# nolint end
```

Start timer.

```{r}
start_time <- Sys.time()
```

Define path to outputs folder.

```{r}
output_dir <- file.path("..", "outputs")
```

## Attempt at incorporating a warm-up period into `model.py`

### Run the model

Run the model for `warm_up_period` + `data_collection_period`...

To illustrate our problem, have temporarily add another resource: doctor.

```{r}
run_number <- 1
param <- parameters()
set_seed <- TRUE
number_of_doctors <- 3

param$warm_up_period
param$data_collection_period
```

```{r}
# Check all inputs are valid
valid_inputs(run_number, param)

# Set random seed based on run number
if (set_seed) {
  set.seed(run_number)
}

# Define the patient trajectory
patient <- trajectory("appointment") %>%
  seize("nurse", 1L) %>%
  timeout(function() {
    rexp(n = 1L, rate = 1L / param[["mean_n_consult_time"]])
  }) %>%
  release("nurse", 1L) %>%
  seize("doctor", 1L) %>%
  timeout(function() {
    rexp(n = 1L, rate = 1L / param[["mean_n_consult_time"]])
  }) %>%
  release("doctor", 1L)

# Determine whether to get verbose activity logs
verbose <- any(c(param[["log_to_console"]], param[["log_to_file"]]))

# Create simmer environment, add nurse resource and patient generator, and
# run the simulation. Capture output, which will save a log if verbose=TRUE
sim_log <- capture.output(
  env <- simmer("simulation", verbose = verbose) %>% # nolint
    add_resource("nurse", param[["number_of_nurses"]]) %>%
    add_resource("doctor", number_of_doctors) %>%
    add_generator("patient", patient, function() {
      rexp(n = 1L, rate = 1L / param[["patient_inter"]])
    }) %>%
    simmer::run(param[["warm_up_period"]] +
                param[["data_collection_period"]]) %>%
    wrap()
)
```

### Trim the `arrivals` and `resources` dataframes produced

Label warm-up and data-collection patients in the `arrivals` dataframe.

```{r}
arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)

# Add column marking warm-up (wu) and data-collection (dc) patients
arrivals <- arrivals %>%
  group_by(name) %>%
  # filter(all(start_time >= param[["warm_up_period"]])) %>%
  mutate(period = if_else(
    any(start_time < param[["warm_up_period"]]), "wu", "dc"
  )) %>%
  ungroup()
arrivals
```

As `resources` does not contain only information on which patient they were associated with, we need to match the resource start time with the patient activity start times.

First, we must calculate the `resource_start_time` (as the `start_time` in `arrivals` may be earlier if the patient had to wait for the resource).

```{r}
# Add column recording the resource start time (excluding wait time for resource)
arrivals[["resource_start_time"]] <- (
  arrivals[["end_time"]] - arrivals[["activity_time"]]
)
arrivals
```

**Question:** Is `resource_start_time` just the same as start time? If patients had to wait for a resource, does activity_time include that?

**Answer:** No.

```{r}
# Instances where start_time is different from resource_start_time
arrivals[round(arrivals$start_time, 10) != round(arrivals$resource_start_time, 10),]
```

In the `resources` dataframe, we just has `time` (which is for an event - including start time or end time).

```{r}
resources <- get_mon_resources(env)
resources
```

```{r}
# Create arrivals dataframe with rows for each patient's resource start and end time
arrivals_times <- arrivals %>%
  select(name, resource, resource_start_time, end_time, replication, period) %>%
  pivot_longer(cols = c(resource_start_time, end_time),
               names_to = "time_type",
               values_to = "time_value")

arrivals_times
```

```{r}
# Sort both dataframes by time and round (otherwise everything doesn't match
# due to floating point differences)
decimal_places <- 10

arrivals_times <- arrivals_times %>%
  arrange(time_value) %>%
  mutate(time_value_r = round(time_value, decimal_places))

resources <- resources %>%
  mutate(time_r = round(time, decimal_places))

# Preview
arrivals_times
resources
```

```{r}
# Merge the dataframes
matched_data <- left_join(
  resources, arrivals_times,
  by = c("time_r" = "time_value_r",
         "resource" = "resource",
         "replication" = "replication")
)
matched_data
```

Unfortunately, some resources had no match, which is not allowable, as they must be associated with a patient, remaining the case even if we round by more decimal places (unshown).

```{r}
matched_data[is.na(matched_data[["name"]]),]
```

Looking manually...

#### nurse 60.36518

No match in `arrivals_times`

```{r}
arrivals_times %>%
  arrange(time_value) %>%
  filter(time_value > 58 & time_value < 62)
```

Does match in `arrivals` - interestingly, to `start_time` rather than `resource_start_time`.

```{r}
arrivals %>%
  arrange(start_time) %>%
  filter(start_time > 58 & start_time < 62)
```

This is because that entry in resources is about someone joining the queue, and not about a resource being used.

Can check this by seeing that `patient15` has matches for the resource_start_time and end_time...

```{r}
matched_data[matched_data[["name"]] == "patient15",]
```

Hence, the **solution** could be:

* To have `start_time` as an additional `time_type` ONLY IF they experienced a wait, or-
* To filter `resources` to only contain rows from patients capturing or releasing a resource and not joining the queue

BUT: note that my plans could have unintended calculations if I remove rows (either from approach in general, or from the latter item) that are required by the calculations.

### Revisiting this approach

These are the patients with mismatch between `resource_start_time` and `start_time`.

```{r}
options(digits = 22)

arrivals %>%
  select(name, resource, start_time, resource_start_time, end_time, replication, period) %>%
  filter(start_time != resource_start_time)
```

Those with `resource_start_time` > `start_time` should indicate they had to wait, but some of these may just be floating point differences, such as:

* Those very similar
* Those with a slightly higher `resource_start_time`

```{r}
arrivals %>%
  select(name, resource, start_time, resource_start_time, end_time, replication, period) %>%
  filter(start_time > resource_start_time)
```

We can investigate this by cross-referencing for the equivalent times in `resources`.

By manual inspection, we can see that those with very close times were just floating point issues, as there is only one entry in resources.

For those with the larger gaps (60, 105, 110) they have entries in resources for start_time and resource_start_time, indicating a wait.

* `patient15` (60, 61, 74)
* `patient22` (104, 105, 128)
* `patient24` (110, 112, 115)

```{r}
resources <- get_mon_resources(env)
resources %>%
  arrange(time)
```

Our options here are to either:

* Filter arrivals to only include `start_time` if difference after rounding ---> issue, if there is a true difference, hidden by rounding
* Match all start, resource start and end times.

Trying option 2 first...

```{r}
# Create arrivals dataframe with rows for each patient's resource start and end time
arrivals_times <- arrivals %>%
  select(name, resource, start_time, resource_start_time, end_time, replication, period) %>%
  pivot_longer(cols = c(start_time, resource_start_time, end_time),
               names_to = "time_type",
               values_to = "time_value")

arrivals_times <- arrivals_times %>%
  arrange(time_value)

resources <- resources %>%
  arrange(time)

# Merge the dataframes
matched_data <- left_join(
  resources, arrivals_times,
  by = c("time" = "time_value",
         "resource" = "resource",
         "replication" = "replication")
)
matched_data
```

No mismatch!

```{r}
matched_data[is.na(matched_data[["name"]]),]
```

However, we have added duplicate rows, where `start_time` and `resource_start_time` are the same...

```{r}
dim(resources)
dim(matched_data)
```

This could be addressed by removing duplicates...

```{r}
# Remove resource_start_time in cases where it duplicates start_time
arrivals_times_clean <- arrivals_times %>%
  group_by(name, resource, replication, period, time_value) %>%
  filter(!(n() > 1 & any(time_type == "start_time") & time_type == "resource_start_time")) %>%
  ungroup()

# Merge the dataframes
matched_data2 <- left_join(
  resources, arrivals_times_clean,
  by = c("time" = "time_value",
         "resource" = "resource",
         "replication" = "replication")
)
matched_data2
```

Now less rows, but still 7 more than before! We need to identify which patients have surplus rows. By filtering to those with 5 + rows, we see the surplus is for patients who had a wait:

* `patient15` (60, 61, 74)
* `patient22` (104, 105, 128)
* `patient24` (110, 112, 115)

HOWEVER it does not include patient22.

```{r}
matched_data2 %>%
  group_by(name) %>%
  filter(n() > 4) %>%
  ungroup()
```

For `patient22`'s doctors appointment, it has matched for when they joined the queue, but not for when they started the appointment.

```{r}
matched_data2 %>%
  filter(name == "patient22")
```

Filtering for NA's though, we don't see anything.

Instead, lets look for times around the expect time of the appointment. As a reminder:

```
patient22	doctor	104.556807495089344683947	105.448863449860368746158	128.573579711864510954911	1	dc
```

We see a match, for patient17's end time.

```{r}
matched_data2 %>%
  filter(time > 104 & time < 106)
```

```{r}
get_mon_resources(env) %>%
  filter(time > 104 & time < 107)
```

### Matching without end_time

```{r}
# Remove end times
arrivals_start_times_clean <- arrivals_times_clean %>%
  filter(time_type != "end_time")

# Merge the dataframes
matched_data3 <- left_join(
  resources, arrivals_start_times_clean,
  by = c("time" = "time_value",
         "resource" = "resource",
         "replication" = "replication")
)
matched_data3
```

Now we see it has matched to patient22.

```{r}
matched_data3 %>%
  filter(time > 104 & time < 106)
```

However, there are some duplicate rows (e.g. patient21 matched on start time twice).

```{r}
# Viewing duplicates
matched_data3 %>%
  drop_na(name) %>%
  group_by(name) %>%
  filter(n() > 2) %>%
  ungroup()

# Viewing original resources for patient21
get_mon_resources(env) %>%
  filter(time > 88 & time < 89)

# Viewing original arrivals for patient21
arrivals %>%
  filter(name == "patient21")
get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE) %>%
  filter(name == "patient21")
```

### Why does arrivals have duplicate rows?

Lets see if this is a wider issue.

```{r}
run_number <- 1
param <- parameters()
set_seed <- TRUE
number_of_doctors <- 3

# Check all inputs are valid
valid_inputs(run_number, param)

# Set random seed based on run number
if (set_seed) {
  set.seed(run_number)
}

# Define the patient trajectory
patient <- trajectory("appointment") %>%
  seize("nurse", 1L) %>%
  timeout(function() {
    rexp(n = 1L, rate = 1L / param[["mean_n_consult_time"]])
  }) %>%
  release("nurse", 1L) %>%
  seize("doctor", 1L) %>%
  timeout(function() {
    rexp(n = 1L, rate = 1L / param[["mean_n_consult_time"]])
  }) %>%
  release("doctor", 1L)

# Determine whether to get verbose activity logs
verbose <- any(c(param[["log_to_console"]], param[["log_to_file"]]))

# Create simmer environment, add nurse resource and patient generator, and
# run the simulation. Capture output, which will save a log if verbose=TRUE
sim_log <- capture.output(
  env <- simmer("simulation", verbose = verbose) %>% # nolint
    add_resource("nurse", param[["number_of_nurses"]]) %>%
    add_resource("doctor", number_of_doctors) %>%
    add_generator("patient", patient, function() {
      rexp(n = 1L, rate = 1L / param[["patient_inter"]])
    }) %>%
    simmer::run(param[["warm_up_period"]] +
                param[["data_collection_period"]]) %>%
    wrap()
)

arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)
resources <- get_mon_resources(env)
```

The max time is 130. All these patients were ones who were seen by a nurse, but still waiting for or in consultation with a doctor at the end of the time period.

```{r}
arrivals %>%
  group_by(name) %>%
  filter(n() > 2) %>%
  arrange(name)
```

These are lost if ongoing = FALSE.

```{r}
get_mon_arrivals(env, per_resource = TRUE, ongoing = FALSE) %>%
  group_by(name)%>%
  filter(n() > 2)

get_mon_arrivals(env, per_resource = TRUE, ongoing = FALSE) %>%
  filter(name %in% c("patient21", "patient23", "patient25", "patient26"))
```
Hence, I think it is reasonable to drop these rows for these patients.

### Returning to the warm-up calculations

To summarise, our aim now is:

* Add column marking warm-up and data collection patients.
* Drop rows for patients with blank next to resource, if they already have times by the resource (BUT: could this be an issue if they revisit a resource in a simulation?)
* Calculate resource start time.
* Pivot the dataframe.
* Match on start time and resource start time in the first instance.
* Then, fill remaining blanks by matching on end time.
* Then check for NA.

Lets do it from scratch from `env` step.

```{r}
arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)
arrivals
```

```{r}
# Add column marking warm-up (wu) and data-collection (dc) patients
arrivals <- arrivals %>%
  group_by(name) %>%
  mutate(period = if_else(
    any(start_time < param[["warm_up_period"]]), "wu", "dc"
  )) %>%
  ungroup()

# Remove the blank entries for patients with  more rows than number of
# resources (2), who have a complete version and blank version of same row
arrivals <- arrivals %>%
  group_by(name)%>%
  mutate(group_size = n()) %>%
  group_by(name, resource) %>%
  filter(!(
    any(!is.na(start_time) & !is.na(end_time) &
          !is.na(activity_time)) & is.na(end_time)
    ) | group_size <= 2) %>%
  select(-group_size)

arrivals
```

```{r}
# Add column recording the resource start time (excluding wait time for resource)
arrivals[["resource_start_time"]] <- (
  arrivals[["end_time"]] - arrivals[["activity_time"]]
)

# Pivot dataframe so rows for each patient's resource start and end time
arrivals_times <- arrivals %>%
  select(name, resource, start_time, resource_start_time, end_time, replication, period) %>%
  pivot_longer(cols = c(start_time, resource_start_time, end_time),
               names_to = "time_type",
               values_to = "time_value")

arrivals_times
```

```{r}
matched_data4 <- resources %>%
    left_join(arrivals, by = c("resource", "replication", "time" = "start_time")) %>%
    left_join(arrivals, by = c("resource", "replication", "time" = "resource_start_time"), suffix = c("", "_rs")) %>%
    left_join(arrivals, by = c("resource", "replication", "time" = "end_time"), suffix = c("", "_et")) %>%
    mutate(
      name = coalesce(name, name_rs, name_et),
      match_type = case_when(
        !is.na(name) ~ "start_time",
        !is.na(name_rs) ~ "resource_start_time",
        !is.na(name_et) ~ "end_time",
        TRUE ~ NA_character_
      ),
      period = coalesce(period, period_rs, period_et)
    ) %>%
    select(resource, time, server, queue, capacity, queue_size, system, limit, replication,
           name, match_type, period)
matched_data4
```

Checking for NA...

```{r}
matched_data4 %>%
  filter(is.na(name))
```

Checking if it matched patient17 or patient22...

```{r}
matched_data4 %>%
  filter(time > 104 & time < 106)
```

## Attempt using `reset()`

```{r}
run_number <- 1
param <- parameters(
  patient_inter = 5,
  mean_n_consult_time = 20,
  number_of_nurses = 1,
  warm_up_period = 80,
  data_collection_period = 80
)
set_seed <- TRUE
number_of_doctors <- 3

# Check all inputs are valid
valid_inputs(run_number, param)

# Set random seed based on run number
if (set_seed) {
  set.seed(run_number)
}

# Define the patient trajectory
patient <- trajectory("appointment") %>%
  seize("nurse", 1L) %>%
  timeout(function() {
    rexp(n = 1L, rate = 1L / param[["mean_n_consult_time"]])
  }) %>%
  release("nurse", 1L)

# Create simmer environment, add nurse resource and patient generator
env <- simmer("simulation", verbose = verbose) %>% # nolint
  add_resource("nurse", param[["number_of_nurses"]]) %>%
  add_generator("patient", patient, function() {
    rexp(n = 1L, rate = 1L / param[["patient_inter"]])
  })

# Run the warm-up period
env %>%
  simmer::run(param[["warm_up_period"]])

# Extract monitoring data *before* the reset
wu_arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)
wu_resources <- get_mon_resources(env)

# Reset the environment to clear statistics
env %>%
  simmer::reset()

# Run the data collection period
sim_log <- capture.output(
  env %>%
    simmer::run(param[["data_collection_period"]]) %>%
    wrap()
)

# Extract monitoring data *after* the reset
arrivals <- get_mon_arrivals(env, per_resource = TRUE, ongoing = TRUE)
resources <- get_mon_resources(env)

# Display
wu_arrivals %>% arrange(start_time)
wu_resources
arrivals %>% arrange(start_time)
resources
```

It appears that in `wu_arrivals`, patients `end_time` = NA in some cases as not yet seen but in others as they start being seen but not finished before end of simulation.

**TODO:** Find a way to distinguish patients still waiting for a resource v.s. patients in ongoing session with resource (perhaps by matching with resource times).

When we reset, these are no longer monitored so not included in the new dataframes. However, I am concerned they simply no longer exist, as the patients in `arrivals` should all be waiting and not seen immediately, but `patient0` seems to be seen as soon as they arrive.
